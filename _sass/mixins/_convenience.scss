@mixin mq($breakpoints: $bp, $queries: (lt: max, gt: min)) {
    @if type-of(nth($breakpoints, 1)) == "string" {
        $new-breakpoints: ();
        @for $i from 1 through length($breakpoints) {
            $name: nth($breakpoints, $i);
            @if map-has-key($bp, $name) {
                $new-breakpoints: map-merge($new-breakpoints, ($name: map-get($bp, $name)));
            } @else {
                @warn "No value in $bp corresponding to breakpoint name '#{$name}', skipping.";
            }
        }
        $breakpoints: $new-breakpoints;
    }
    @each $prefix, $query in $queries {
        $sorted-bp: map-sort-units($breakpoints, $order: px em);
        @for $i from 1 through length($sorted-bp) {
            $unit-set: map-sort(nth($sorted-bp, $i));
            @if $query == "max" {
                $unit-set: map-reverse($unit-set);
            }
            $sorted-bp: set-nth($sorted-bp, $i, $unit-set);
        }
        $sorted-bp: merge-all($sorted-bp);

        @each $name, $breakpoint in $sorted-bp {
            @if ($query == "min") and (index('px', unit($breakpoint))) {
                $breakpoint: $breakpoint + 1;
            }

            &-#{$prefix}-#{$name} {
                @media screen and (#{$query}-width: $breakpoint) {
                    @content;
                }
            }
        }
    }
}

@mixin display($display) {
    display: $display;

    &.show {
        @include mq {
            display: $display;
        }
    }
}

@mixin fixed-ratio($x, $y, $width: 100%) {
    width: $width;
    height: 0;
    padding-top: $y/$x * $width;
}

@mixin columns-reset($break-point) { // mobile reset
    @media screen and (max-width: $break-point) {
        .cell {
            display: block;

            .button {
                position: static;
                margin: 0 auto $default-spacing;
            }

            &:last-child > :last-child { // mobile only: remove bottom margin of last element in table
                margin-bottom: 0;
            }
        }

        &.button-columns .cell {
            padding-bottom: 0;
        }
    }

    @media screen and (min-width: $break-point + 1px) { // desktop only: remove bottom margin of all last element in each cell
        .cell > :last-child {
            margin-bottom: 0;
        }
    }
}

@mixin columns ($columns, $spacing: 0px) {
    @if not($columns > 1) { @error "columns mixin must have more than one column." }
    $width: 100% / $columns;
    $row-end: $columns + "n";
    width: calc(#{$width} - #{($spacing * ($columns - 1) / $columns)});
    margin-right: $spacing;
    margin-bottom: $spacing;

    &:nth-child(#{$row-end}), &:last-child {
        margin-right: 0;
    }
}

@mixin blur($blur) {
    -webkit-filter: blur($blur);
    filter: blur($blur);
}

// This mixin applies the effects its contents when a element
// with class "hover" (either same element or a parent) is hovered
@mixin hover($hover-class: "hover") {
    &.#{$hover-class}:hover, .#{$hover-class}:hover & {
        @content;
    }
}

@mixin no-hover($hover-class: "hover") {
    &.#{$hover-class}:not(:hover), .#{$hover-class}:not(:hover) & {
        @content;
    }
}

// same idea with a target class
@mixin target($target-class: "target") {
    &.#{$target-class}:target, .#{$target-class}:target & {
        @content;
    }
}

@mixin no-target($target-class: "target") {
    &.#{$target-class}:not(:target), .#{$target-class}:not(:target) & {
        @content;
    }
}

@mixin transform($transform) {
    -webkit-transform: $transform;
    transform: $transform;

    &.hw-accel {
        -webkit-transform: $transform translateZ(0);
        transform: $transform translateZ(0);
    }
}
